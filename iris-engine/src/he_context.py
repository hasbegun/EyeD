"""OpenFHE BFV context for homomorphic encryption of iris templates.

Provides encrypt/decrypt/serialize/deserialize for iris codes using the BFV
scheme with parameters tuned for binary iris code matching:

    - Plaintext modulus t = 65537 (Fermat prime, > 8192 so rotate-and-sum
      produces correct integer inner product instead of XOR parity)
    - Multiplicative depth = 1 (one ct×ct multiply for inner product)
    - Security level = 128-bit (HE standard)
    - Ring dimension N auto-selected by OpenFHE (expected 8192 or 16384)

NOTE on t=65537 vs t=2: With t=2 addition is XOR (mod 2), so rotate-and-sum
would give parity instead of the integer count we need for Hamming distance.
t=65537 gives true integer addition, allowing correct inner product
accumulation of up to 8192 binary values without overflow.

Key distribution:
    - PoC / test mode: all keys held locally (init_context generates keypair)
    - Production mode: public key + eval keys loaded from files (generated by
      key-service). Secret key never present in iris-engine.

Usage:
    from .he_context import init_context, encrypt_iris_code, he_inner_product
    init_context()                         # Call once at startup
    ct = encrypt_iris_code(iris_code_arr)  # np.ndarray (16,256,2) → Ciphertext
    ip = he_inner_product(ct1, ct2)        # Encrypted inner product
"""

from __future__ import annotations

import logging
import os
import struct
import tempfile
from pathlib import Path
from typing import Optional

import numpy as np

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# Module state (initialized by init_context)
# ---------------------------------------------------------------------------

_context = None          # openfhe.CryptoContext
_public_key = None       # openfhe.PublicKey
_secret_key = None       # openfhe.PrivateKey (only in PoC / test mode)
_initialized: bool = False

# Expected iris code shape from Open-IRIS: 16 scales × 256 angles × 2 (re/im)
IRIS_CODE_SHAPE = (16, 256, 2)
IRIS_CODE_SLOTS = 16 * 256 * 2  # = 8192

# BFV parameters
_PLAINTEXT_MODULUS = 65537  # Fermat prime F4; > 8192 for correct accumulation
_MULT_DEPTH = 1             # One ct×ct multiply for inner product

# Number of rotate-and-sum iterations: ceil(log2(8192)) = 13
_ROTATE_SUM_ITERS = 13


# ---------------------------------------------------------------------------
# Initialization
# ---------------------------------------------------------------------------


def init_context(
    key_dir: Optional[str] = None,
    generate_secret: bool = False,
) -> None:
    """Initialize the BFV crypto context and load keys.

    Args:
        key_dir: Directory containing serialized keys (public.key, eval_mult.key,
                 eval_rotate.key). If None, generates a fresh keypair (PoC mode).
        generate_secret: If True with key_dir, also generate and save a new keypair.
                        If False with key_dir, load existing keys from files.
    """
    global _context, _public_key, _secret_key, _initialized

    import openfhe

    # --- Create BFV context ---
    params = openfhe.CCParamsBFVRNS()
    params.SetPlaintextModulus(_PLAINTEXT_MODULUS)
    params.SetMultiplicativeDepth(_MULT_DEPTH)
    params.SetSecurityLevel(openfhe.SecurityLevel.HEStd_128_classic)

    _context = openfhe.GenCryptoContext(params)
    _context.Enable(openfhe.PKESchemeFeature.PKE)
    _context.Enable(openfhe.PKESchemeFeature.KEYSWITCH)
    _context.Enable(openfhe.PKESchemeFeature.LEVELEDSHE)

    ring_dim = _context.GetRingDimension()
    logger.info(
        "BFV context created: t=%d, mult_depth=%d, ring_dim=%d, slots=%d",
        _PLAINTEXT_MODULUS, _MULT_DEPTH, ring_dim, ring_dim,
    )

    if ring_dim < IRIS_CODE_SLOTS:
        raise RuntimeError(
            f"Ring dimension {ring_dim} < {IRIS_CODE_SLOTS} iris code slots. "
            "Cannot pack a full iris code into one ciphertext."
        )

    if key_dir and not generate_secret:
        # Production mode: load keys from files (no secret key)
        _load_keys_from_dir(key_dir)
    elif key_dir and generate_secret:
        # Key generation mode: create and save keypair
        _generate_and_save_keys(key_dir)
    else:
        # PoC / test mode: generate ephemeral keypair in memory
        _generate_ephemeral_keys()

    _initialized = True
    has_secret = _secret_key is not None
    logger.info(
        "HE context initialized (secret_key=%s, key_dir=%s)",
        "present" if has_secret else "absent",
        key_dir or "ephemeral",
    )


def _generate_ephemeral_keys() -> None:
    """Generate a fresh keypair in memory (PoC / test mode)."""
    global _public_key, _secret_key

    keypair = _context.KeyGen()
    _public_key = keypair.publicKey
    _secret_key = keypair.secretKey

    # Generate eval keys for multiplication and rotation
    _context.EvalMultKeyGen(_secret_key)
    rotation_indices = [1 << i for i in range(_ROTATE_SUM_ITERS)]
    _context.EvalRotateKeyGen(_secret_key, rotation_indices)


def _generate_and_save_keys(key_dir: str) -> None:
    """Generate keypair and save to files."""
    import openfhe

    _generate_ephemeral_keys()

    key_path = Path(key_dir)
    key_path.mkdir(parents=True, exist_ok=True)

    # Save crypto context
    openfhe.SerializeToFile(
        str(key_path / "cryptocontext.bin"), _context, openfhe.BINARY
    )
    # Save public key
    openfhe.SerializeToFile(
        str(key_path / "public.key"), _public_key, openfhe.BINARY
    )
    # Save secret key (key-service only!)
    openfhe.SerializeToFile(
        str(key_path / "secret.key"), _secret_key, openfhe.BINARY
    )
    # Save eval keys (mult + rotation)
    _context.SerializeEvalMultKey(
        str(key_path / "eval_mult.key"), openfhe.BINARY
    )
    _context.SerializeEvalAutomorphismKey(
        str(key_path / "eval_rotate.key"), openfhe.BINARY
    )

    logger.info("Keys saved to %s", key_dir)


def _load_keys_from_dir(key_dir: str) -> None:
    """Load public key + eval keys from files (no secret key)."""
    import openfhe

    global _context, _public_key

    key_path = Path(key_dir)

    # Deserialize crypto context (replaces the one we created above)
    _context, ok = openfhe.DeserializeCryptoContext(
        str(key_path / "cryptocontext.bin"), openfhe.BINARY
    )
    if not ok:
        raise RuntimeError(f"Failed to deserialize crypto context from {key_dir}")

    # Re-enable features on the deserialized context
    _context.Enable(openfhe.PKESchemeFeature.PKE)
    _context.Enable(openfhe.PKESchemeFeature.KEYSWITCH)
    _context.Enable(openfhe.PKESchemeFeature.LEVELEDSHE)

    # Load public key
    _public_key, ok = openfhe.DeserializePublicKey(
        str(key_path / "public.key"), openfhe.BINARY
    )
    if not ok:
        raise RuntimeError(f"Failed to deserialize public key from {key_dir}")

    # Load eval keys
    ok = _context.DeserializeEvalMultKey(
        str(key_path / "eval_mult.key"), openfhe.BINARY
    )
    if not ok:
        raise RuntimeError(f"Failed to deserialize eval mult key from {key_dir}")

    ok = _context.DeserializeEvalAutomorphismKey(
        str(key_path / "eval_rotate.key"), openfhe.BINARY
    )
    if not ok:
        raise RuntimeError(f"Failed to deserialize eval rotate key from {key_dir}")

    logger.info("Loaded public key + eval keys from %s (no secret key)", key_dir)


def is_initialized() -> bool:
    """Return True if the HE context has been initialized."""
    return _initialized


def has_secret_key() -> bool:
    """Return True if the secret key is available (PoC mode only)."""
    return _secret_key is not None


def get_ring_dimension() -> int:
    """Return the ring dimension N of the BFV context."""
    if not _initialized:
        raise RuntimeError("HE context not initialized")
    return _context.GetRingDimension()


# ---------------------------------------------------------------------------
# Encrypt / Decrypt iris codes
# ---------------------------------------------------------------------------


def encrypt_iris_code(arr: np.ndarray) -> object:
    """Encrypt a single iris code array into a BFV ciphertext.

    Args:
        arr: Iris code array of shape (16, 256, 2) with binary values {0, 1}.

    Returns:
        OpenFHE Ciphertext object.
    """
    if not _initialized:
        raise RuntimeError("HE context not initialized")

    flat = arr.flatten().astype(int).tolist()
    if len(flat) != IRIS_CODE_SLOTS:
        raise ValueError(
            f"Iris code has {len(flat)} values, expected {IRIS_CODE_SLOTS}"
        )

    # Pad to ring dimension if needed (remaining slots = 0)
    ring_dim = _context.GetRingDimension()
    if len(flat) < ring_dim:
        flat.extend([0] * (ring_dim - len(flat)))

    pt = _context.MakePackedPlaintext(flat)
    return _context.Encrypt(_public_key, pt)


def decrypt_iris_code(ct: object) -> np.ndarray:
    """Decrypt a ciphertext back to an iris code array.

    Only available when the secret key is present (PoC / key-service mode).

    Returns:
        np.ndarray of shape (16, 256, 2) with integer values.
    """
    if not _initialized:
        raise RuntimeError("HE context not initialized")
    if _secret_key is None:
        raise RuntimeError(
            "Secret key not available — decryption requires key-service"
        )

    pt = _context.Decrypt(ct, _secret_key)
    pt.SetLength(IRIS_CODE_SLOTS)
    values = pt.GetPackedValue()
    return np.array(values, dtype=np.int32).reshape(IRIS_CODE_SHAPE)


def decrypt_scalar(ct: object) -> int:
    """Decrypt a ciphertext and return the value in slot 0.

    Used for inner product results (scalar value after rotate-and-sum).
    Only available with secret key.
    """
    if not _initialized:
        raise RuntimeError("HE context not initialized")
    if _secret_key is None:
        raise RuntimeError(
            "Secret key not available — decryption requires key-service"
        )

    pt = _context.Decrypt(ct, _secret_key)
    pt.SetLength(1)
    return int(pt.GetPackedValue()[0])


# ---------------------------------------------------------------------------
# Homomorphic operations
# ---------------------------------------------------------------------------


def he_multiply(ct1: object, ct2: object) -> object:
    """Element-wise ciphertext × ciphertext multiplication (with relinearization).

    For binary inputs, this computes AND: a_i * b_i for each slot i.
    """
    if not _initialized:
        raise RuntimeError("HE context not initialized")
    return _context.EvalMult(ct1, ct2)


def he_inner_product(ct1: object, ct2: object) -> object:
    """Compute encrypted inner product: sum(a_i * b_i) for all slots.

    Performs ct×ct multiply followed by rotate-and-sum to accumulate
    all slot products into slot 0. The result ciphertext holds the
    inner product in slot 0.

    For binary iris codes, this gives popcount(a AND b).
    """
    if not _initialized:
        raise RuntimeError("HE context not initialized")

    # Element-wise multiplication (AND for binary values)
    product = _context.EvalMult(ct1, ct2)

    # Rotate-and-sum: accumulate all slots into slot 0
    result = product
    for i in range(_ROTATE_SUM_ITERS):
        shift = 1 << i  # 1, 2, 4, 8, ..., 4096
        rotated = _context.EvalRotate(result, shift)
        result = _context.EvalAdd(result, rotated)

    return result


# ---------------------------------------------------------------------------
# Serialization (file-based — openfhe-python only supports file I/O)
# ---------------------------------------------------------------------------

# Blob format for serialized ciphertexts stored in DB:
# HEv1 (4B) || num_cts (4B, uint32 LE) || [len_ct (4B) || ct_bytes]...
_HE_PREFIX = b"HEv1"


def serialize_ciphertext(ct: object) -> bytes:
    """Serialize a single ciphertext to bytes."""
    import openfhe

    if not _initialized:
        raise RuntimeError("HE context not initialized")

    with tempfile.NamedTemporaryFile(delete=False, suffix=".bin") as f:
        tmp_path = f.name

    try:
        ok = openfhe.SerializeToFile(tmp_path, ct, openfhe.BINARY)
        if not ok:
            raise RuntimeError("SerializeToFile failed for ciphertext")
        with open(tmp_path, "rb") as f:
            return f.read()
    finally:
        try:
            os.unlink(tmp_path)
        except OSError:
            pass


def deserialize_ciphertext(data: bytes) -> object:
    """Deserialize bytes back to a Ciphertext object.

    The crypto context must be initialized first.
    """
    import openfhe

    if not _initialized:
        raise RuntimeError("HE context not initialized")

    with tempfile.NamedTemporaryFile(delete=False, suffix=".bin") as f:
        f.write(data)
        tmp_path = f.name

    try:
        ct, ok = openfhe.DeserializeCiphertext(tmp_path, openfhe.BINARY)
        if not ok:
            raise RuntimeError("DeserializeCiphertext failed")
        return ct
    finally:
        try:
            os.unlink(tmp_path)
        except OSError:
            pass


def pack_he_codes(codes: list[np.ndarray]) -> bytes:
    """Encrypt and serialize a list of iris/mask code arrays into a single blob.

    Blob format: HEv1 (4B) || count (4B LE) || [len (4B LE) || ct_bytes]...

    Args:
        codes: List of numpy arrays, each of shape (16, 256, 2).

    Returns:
        Bytes blob suitable for storage in PostgreSQL BYTEA.
    """
    parts: list[bytes] = []
    for arr in codes:
        ct = encrypt_iris_code(arr)
        ct_bytes = serialize_ciphertext(ct)
        parts.append(ct_bytes)

    # Build blob: prefix + count + length-prefixed ciphertexts
    buf = bytearray(_HE_PREFIX)
    buf.extend(struct.pack("<I", len(parts)))
    for ct_bytes in parts:
        buf.extend(struct.pack("<I", len(ct_bytes)))
        buf.extend(ct_bytes)
    return bytes(buf)


def pack_he_codes_from_cts(cts: list) -> bytes:
    """Serialize a list of already-encrypted Ciphertext objects into HEv1 blob.

    Unlike pack_he_codes() which encrypts numpy arrays first, this takes
    existing Ciphertext objects (e.g. from in-memory gallery) and just
    serializes them.

    Args:
        cts: List of OpenFHE Ciphertext objects.

    Returns:
        Bytes blob in HEv1 format.
    """
    if not _initialized:
        raise RuntimeError("HE context not initialized")

    parts: list[bytes] = []
    for ct in cts:
        ct_bytes = serialize_ciphertext(ct)
        parts.append(ct_bytes)

    buf = bytearray(_HE_PREFIX)
    buf.extend(struct.pack("<I", len(parts)))
    for ct_bytes in parts:
        buf.extend(struct.pack("<I", len(ct_bytes)))
        buf.extend(ct_bytes)
    return bytes(buf)


def unpack_he_codes(data: bytes) -> list:
    """Deserialize a blob back to a list of Ciphertext objects (NO decryption).

    Returns:
        List of OpenFHE Ciphertext objects.
    """
    if data[:4] != _HE_PREFIX:
        raise ValueError(
            f"Expected HE blob prefix {_HE_PREFIX!r}, got {data[:4]!r}"
        )

    offset = 4
    (count,) = struct.unpack("<I", data[offset : offset + 4])
    offset += 4

    cts = []
    for _ in range(count):
        (ct_len,) = struct.unpack("<I", data[offset : offset + 4])
        offset += 4
        ct_bytes = data[offset : offset + ct_len]
        offset += ct_len
        cts.append(deserialize_ciphertext(ct_bytes))

    return cts


def is_he_blob(data: bytes) -> bool:
    """Check if a BYTEA blob is HE-encrypted (starts with HEv1 prefix)."""
    return len(data) >= 4 and data[:4] == _HE_PREFIX


# ---------------------------------------------------------------------------
# Popcount helpers (computed on plaintext before encryption)
# ---------------------------------------------------------------------------


def compute_popcounts(codes: list[np.ndarray]) -> list[int]:
    """Compute popcount (number of 1-bits) for each code array.

    These are stored as plaintext metadata alongside HE ciphertexts,
    needed for Hamming distance computation by the key-service.
    """
    return [int(np.sum(arr.astype(bool))) for arr in codes]


# ---------------------------------------------------------------------------
# Cleanup
# ---------------------------------------------------------------------------


def reset() -> None:
    """Reset module state. Used by tests."""
    global _context, _public_key, _secret_key, _initialized
    _context = None
    _public_key = None
    _secret_key = None
    _initialized = False
